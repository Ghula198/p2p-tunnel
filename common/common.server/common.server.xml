<?xml version="1.0"?>
<doc>
    <assembly>
        <name>common.server</name>
    </assembly>
    <members>
        <member name="T:common.server.IConnection">
            <summary>
            连接对象
            </summary>
        </member>
        <member name="P:common.server.IConnection.ConnectId">
            <summary>
            连接id
            </summary>
        </member>
        <member name="P:common.server.IConnection.Connected">
            <summary>
            已连接
            </summary>
        </member>
        <member name="P:common.server.IConnection.Relay">
            <summary>
            是否是中继
            </summary>
        </member>
        <member name="P:common.server.IConnection.RelayId">
            <summary>
            中继对象id，通过谁中继的，就是谁的id，直连的跟连接id一样
            </summary>
        </member>
        <member name="P:common.server.IConnection.FromConnection">
            <summary>
            来源客户端，中继时，数据来源可能不是给你发数据的那个
            </summary>
        </member>
        <member name="P:common.server.IConnection.EncodeEnabled">
            <summary>
            加密
            </summary>
        </member>
        <member name="P:common.server.IConnection.Crypto">
            <summary>
            加密对象
            </summary>
        </member>
        <member name="M:common.server.IConnection.EncodeEnable(common.libs.ICrypto)">
            <summary>
            启用加密
            </summary>
            <param name="crypto"></param>
        </member>
        <member name="M:common.server.IConnection.EncodeDisable">
            <summary>
            移除加密
            </summary>
        </member>
        <member name="P:common.server.IConnection.SocketError">
            <summary>
            错误
            </summary>
        </member>
        <member name="P:common.server.IConnection.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="P:common.server.IConnection.ServerType">
            <summary>
            连接类型
            </summary>
        </member>
        <member name="P:common.server.IConnection.ReceiveRequestWrap">
            <summary>
            请求数据包装对象
            </summary>
        </member>
        <member name="P:common.server.IConnection.ReceiveResponseWrap">
            <summary>
            回复数据包装对象
            </summary>
        </member>
        <member name="P:common.server.IConnection.ReceiveData">
            <summary>
            接收到的原始数据
            </summary>
        </member>
        <member name="P:common.server.IConnection.SendBytes">
            <summary>
            已发送字节
            </summary>
        </member>
        <member name="P:common.server.IConnection.ReceiveBytes">
            <summary>
            已接收字节
            </summary>
        </member>
        <member name="P:common.server.IConnection.RoundTripTime">
            <summary>
            rtt
            </summary>
        </member>
        <member name="M:common.server.IConnection.Send(System.ReadOnlyMemory{System.Byte})">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.IConnection.Send(System.Byte[],System.Int32)">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.IConnection.Disponse">
            <summary>
            销毁
            </summary>
        </member>
        <member name="M:common.server.IConnection.Clone">
            <summary>
            克隆，主要用于中继
            </summary>
            <returns></returns>
        </member>
        <member name="T:common.server.Connection">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.Connection.ConnectId">
            <summary>
            连接id
            </summary>
        </member>
        <member name="P:common.server.Connection.Connected">
            <summary>
            已连接
            </summary>
        </member>
        <member name="P:common.server.Connection.Relay">
            <summary>
            已中继
            </summary>
        </member>
        <member name="P:common.server.Connection.RelayId">
            <summary>
            中继路线
            </summary>
        </member>
        <member name="P:common.server.Connection.FromConnection">
            <summary>
            来源连接
            </summary>
        </member>
        <member name="P:common.server.Connection.EncodeEnabled">
            <summary>
            启用加密
            </summary>
        </member>
        <member name="P:common.server.Connection.Crypto">
            <summary>
            加密类
            </summary>
        </member>
        <member name="M:common.server.Connection.EncodeEnable(common.libs.ICrypto)">
            <summary>
            启用加密
            </summary>
            <param name="crypto"></param>
        </member>
        <member name="M:common.server.Connection.EncodeDisable">
            <summary>
            移除加密
            </summary>
        </member>
        <member name="P:common.server.Connection.SocketError">
            <summary>
            错误
            </summary>
        </member>
        <member name="P:common.server.Connection.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="P:common.server.Connection.ServerType">
            <summary>
            连接类型
            </summary>
        </member>
        <member name="P:common.server.Connection.ReceiveRequestWrap">
            <summary>
            接收请求数据
            </summary>
        </member>
        <member name="P:common.server.Connection.ReceiveResponseWrap">
            <summary>
            接收回执数据
            </summary>
        </member>
        <member name="P:common.server.Connection.ReceiveData">
            <summary>
            接收数据
            </summary>
        </member>
        <member name="P:common.server.Connection.SendBytes">
            <summary>
            已发送字节
            </summary>
        </member>
        <member name="P:common.server.Connection.ReceiveBytes">
            <summary>
            已接收字节
            </summary>
        </member>
        <member name="P:common.server.Connection.RoundTripTime">
            <summary>
            rtt
            </summary>
        </member>
        <member name="M:common.server.Connection.Send(System.ReadOnlyMemory{System.Byte})">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.Connection.Send(System.Byte[],System.Int32)">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.Connection.Disponse">
            <summary>
            销毁
            </summary>
        </member>
        <member name="M:common.server.Connection.Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="T:common.server.RudpConnection">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.RudpConnection.#ctor(LiteNetLib.NetPeer,System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="peer"></param>
            <param name="address"></param>
        </member>
        <member name="P:common.server.RudpConnection.Connected">
            <summary>
            已连接
            </summary>
        </member>
        <member name="P:common.server.RudpConnection.NetPeer">
            <summary>
            连接对象
            </summary>
        </member>
        <member name="P:common.server.RudpConnection.ServerType">
            <summary>
            连接类型
            </summary>
        </member>
        <member name="P:common.server.RudpConnection.RoundTripTime">
            <summary>
            rtt
            </summary>
        </member>
        <member name="M:common.server.RudpConnection.Send(System.Byte[],System.Int32)">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.RudpConnection.Send(System.ReadOnlyMemory{System.Byte})">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.RudpConnection.Disponse">
            <summary>
            销毁
            </summary>
        </member>
        <member name="M:common.server.RudpConnection.Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="T:common.server.TcpConnection">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.TcpConnection.#ctor(System.Net.Sockets.Socket)">
            <summary>
            
            </summary>
            <param name="tcpSocket"></param>
        </member>
        <member name="P:common.server.TcpConnection.Connected">
            <summary>
            已连接
            </summary>
        </member>
        <member name="P:common.server.TcpConnection.TcpSocket">
            <summary>
            socket
            </summary>
        </member>
        <member name="P:common.server.TcpConnection.ServerType">
            <summary>
            连接类型
            </summary>
        </member>
        <member name="P:common.server.TcpConnection.RoundTripTime">
            <summary>
            rtt
            </summary>
        </member>
        <member name="M:common.server.TcpConnection.Send(System.ReadOnlyMemory{System.Byte})">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.TcpConnection.Send(System.Byte[],System.Int32)">
            <summary>
            发送
            </summary>
            <param name="data"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.TcpConnection.Disponse">
            <summary>
            销毁
            </summary>
        </member>
        <member name="M:common.server.TcpConnection.Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="T:common.server.IMessenger">
            <summary>
            消息接口
            </summary>
        </member>
        <member name="T:common.server.MessengerIdRangeAttribute">
            <summary>
            消息id范围
            </summary>
        </member>
        <member name="P:common.server.MessengerIdRangeAttribute.Min">
            <summary>
            最小
            </summary>
        </member>
        <member name="P:common.server.MessengerIdRangeAttribute.Max">
            <summary>
            最大
            </summary>
        </member>
        <member name="M:common.server.MessengerIdRangeAttribute.#ctor(System.UInt16,System.UInt16)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="T:common.server.MessengerIdAttribute">
            <summary>
            消息id
            </summary>
        </member>
        <member name="P:common.server.MessengerIdAttribute.Id">
            <summary>
            id
            </summary>
        </member>
        <member name="M:common.server.MessengerIdAttribute.#ctor(System.UInt16)">
            <summary>
            
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:common.server.MessengerIdEnumAttribute">
            <summary>
            消息
            </summary>
        </member>
        <member name="T:common.server.IPlugin">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.IPlugin.LoadBefore(Microsoft.Extensions.DependencyInjection.ServiceCollection,System.Reflection.Assembly[])">
            <summary>
            
            </summary>
            <param name="services"></param>
            <param name="assemblys"></param>
        </member>
        <member name="M:common.server.IPlugin.LoadAfter(Microsoft.Extensions.DependencyInjection.ServiceProvider,System.Reflection.Assembly[])">
            <summary>
            
            </summary>
            <param name="services"></param>
            <param name="assemblys"></param>
        </member>
        <member name="T:common.server.PluginLoader">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.PluginLoader.LoadBefore(Microsoft.Extensions.DependencyInjection.ServiceCollection,System.Reflection.Assembly[])">
            <summary>
            
            </summary>
            <param name="services"></param>
            <param name="assemblys"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.PluginLoader.LoadAfter(common.server.IPlugin[],Microsoft.Extensions.DependencyInjection.ServiceProvider,System.Reflection.Assembly[])">
            <summary>
            
            </summary>
            <param name="plugins"></param>
            <param name="services"></param>
            <param name="assemblys"></param>
        </member>
        <member name="T:common.server.IRelaySourceConnectionSelector">
            <summary>
            选择中继来源连接对象，用于提供服务端客户端不同实现
            </summary>
        </member>
        <member name="M:common.server.IRelaySourceConnectionSelector.Select(common.server.IConnection,System.UInt64)">
            <summary>
            选择
            </summary>
            <param name="connection">接收消息的连接对象</param>
            <param name="clientid">客户端id</param>
            <returns></returns>
        </member>
        <member name="T:common.server.RelaySourceConnectionSelector">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.RelaySourceConnectionSelector.Select(common.server.IConnection,System.UInt64)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <param name="clientid"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.IRelayValidator">
            <summary>
            中继权限验证
            </summary>
        </member>
        <member name="M:common.server.IRelayValidator.Validate(common.server.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.DefaultRelayValidator">
            <summary>
            默认的验证
            </summary>
        </member>
        <member name="M:common.server.DefaultRelayValidator.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.DefaultRelayValidator.Validate(common.server.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.IServer">
            <summary>
            服务
            </summary>
        </member>
        <member name="M:common.server.IServer.Start(System.Int32)">
            <summary>
            
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:common.server.IServer.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.IServer.Disponse">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.IServer.InputData(common.server.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="P:common.server.IServer.OnPacket">
            <summary>
            收到包
            </summary>
        </member>
        <member name="P:common.server.IServer.OnDisconnect">
            <summary>
            有人离线
            </summary>
        </member>
        <member name="P:common.server.IServer.OnConnected">
            <summary>
            有人上线
            </summary>
        </member>
        <member name="T:common.server.ITcpServer">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.ITcpServer.SetBufferSize(System.Int32)">
            <summary>
            
            </summary>
            <param name="bufferSize"></param>
        </member>
        <member name="M:common.server.ITcpServer.BindReceive(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.ITcpServer.CreateConnection(System.Net.Sockets.Socket)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.IUdpServer">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.IUdpServer.Start(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="port"></param>
            <param name="timeout"></param>
        </member>
        <member name="M:common.server.IUdpServer.CreateConnection(System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.MessengerResolver">
            <summary>
            消息处理总线
            </summary>
        </member>
        <member name="M:common.server.MessengerResolver.#ctor(common.server.IUdpServer,common.server.ITcpServer,common.server.MessengerSender,common.server.IRelaySourceConnectionSelector,common.server.IRelayValidator)">
            <summary>
            
            </summary>
            <param name="udpserver"></param>
            <param name="tcpserver"></param>
            <param name="messengerSender"></param>
            <param name="sourceConnectionSelector"></param>
            <param name="relayValidator"></param>
        </member>
        <member name="M:common.server.MessengerResolver.LoadMessenger(System.Type,System.Object)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="obj"></param>
        </member>
        <member name="M:common.server.MessengerResolver.InputData(common.server.IConnection)">
            <summary>
            收到消息
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.MessengerResolver.MessengerCacheInfo">
            <summary>
            消息插件缓存
            </summary>
        </member>
        <member name="P:common.server.MessengerResolver.MessengerCacheInfo.Target">
            <summary>
            对象
            </summary>
        </member>
        <member name="P:common.server.MessengerResolver.MessengerCacheInfo.Method">
            <summary>
            方法
            </summary>
        </member>
        <member name="P:common.server.MessengerResolver.MessengerCacheInfo.IsVoid">
            <summary>
            是否void
            </summary>
        </member>
        <member name="P:common.server.MessengerResolver.MessengerCacheInfo.IsTask">
            <summary>
            是否task
            </summary>
        </member>
        <member name="P:common.server.MessengerResolver.MessengerCacheInfo.IsTaskResult">
            <summary>
            是否task 带result
            </summary>
        </member>
        <member name="T:common.server.MessengerSender">
            <summary>
            消息发送器
            </summary>
        </member>
        <member name="F:common.server.MessengerSender.requestIdNumberSpace">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.MessengerSender.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.MessengerSender.SendReply(common.server.model.MessageRequestWrap)">
            <summary>
            发送并等待回复
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.MessengerSender.SendOnly(common.server.model.MessageRequestWrap)">
            <summary>
            只发送，不等回复
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.MessengerSender.ReplyOnly(common.server.model.MessageResponseWrap)">
            <summary>
            回复远程消息，收到某个连接的消息后，通过这个再返回消息给它
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.MessengerSender.Response(common.server.model.MessageResponseWrap)">
            <summary>
            回复本地消息，发送消息后，socket收到消息，通过这个方法回复给刚刚发送的对象
            </summary>
            <param name="wrap"></param>
        </member>
        <member name="T:common.server.MessageResponeInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.MessageResponeInfo.Code">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.MessageResponeInfo.Data">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.TimeoutState">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.TimeoutState.RequestId">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.TimeoutState.Tcs">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.middleware.MiddlewareBase">
            <summary>
            中间件
            </summary>
        </member>
        <member name="P:common.server.middleware.MiddlewareBase.Next">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.middleware.MiddlewareBase.Execute(common.server.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.middleware.MiddlewareTransfer">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.middleware.MiddlewareTransfer.Load(common.server.middleware.MiddlewareBase)">
            <summary>
            
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:common.server.middleware.MiddlewareTransfer.Execute(common.server.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.middleware.ServiceCollectionExtends">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.middleware.ServiceCollectionExtends.AddMiddleware(Microsoft.Extensions.DependencyInjection.ServiceCollection,System.Reflection.Assembly[])">
            <summary>
            
            </summary>
            <param name="services"></param>
            <param name="assemblys"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.middleware.ServiceCollectionExtends.UseMiddleware(Microsoft.Extensions.DependencyInjection.ServiceProvider,System.Reflection.Assembly[])">
            <summary>
            
            </summary>
            <param name="services"></param>
            <param name="assemblys"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.model.ClientsInfo">
            <summary>
            客户端列表
            </summary>
        </member>
        <member name="M:common.server.model.ClientsInfo.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.ClientsInfo.Clients">
            <summary>
            客户端列表
            </summary>
        </member>
        <member name="M:common.server.model.ClientsInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.ClientsInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.ClientsClientInfo">
            <summary>
            客户端
            </summary>
        </member>
        <member name="P:common.server.model.ClientsClientInfo.Id">
            <summary>
            id
            </summary>
        </member>
        <member name="P:common.server.model.ClientsClientInfo.Name">
            <summary>
            名字
            </summary>
        </member>
        <member name="P:common.server.model.ClientsClientInfo.Access">
            <summary>
            权限
            </summary>
        </member>
        <member name="P:common.server.model.ClientsClientInfo.Connection">
            <summary>
            连接对象
            </summary>
        </member>
        <member name="M:common.server.model.ClientsClientInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.ClientsClientInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.model.ClientsMessengerIds">
            <summary>
            客户端相关的消息id
            </summary>
        </member>
        <member name="F:common.server.model.ClientsMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.ClientsMessengerIds.IP">
            <summary>
            获取id
            </summary>
        </member>
        <member name="F:common.server.model.ClientsMessengerIds.Port">
            <summary>
            获取端口
            </summary>
        </member>
        <member name="F:common.server.model.ClientsMessengerIds.AddTunnel">
            <summary>
            添加通道
            </summary>
        </member>
        <member name="F:common.server.model.ClientsMessengerIds.RemoveTunnel">
            <summary>
            删除通道
            </summary>
        </member>
        <member name="F:common.server.model.ClientsMessengerIds.Notify">
            <summary>
            通知
            </summary>
        </member>
        <member name="F:common.server.model.ClientsMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.CommonTaskResponseInfo`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:common.server.model.CommonTaskResponseInfo`1.ErrorMsg">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.CommonTaskResponseInfo`1.Data">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.CounterResultInfo">
            <summary>
            服务器信息
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.OnlineCount">
            <summary>
            在线人数
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.Cpu">
            <summary>
            cpu使用率
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.Memory">
            <summary>
            内存
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.RunTime">
            <summary>
            运行时间
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.TcpSendBytes">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.TcpReceiveBytes">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.UdpSendBytes">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.CounterResultInfo.UdpReceiveBytes">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.model.CounterResultInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.CounterResultInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.CounterMessengerIds">
            <summary>
            服务器信息相关消息id
            </summary>
        </member>
        <member name="F:common.server.model.CounterMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.CounterMessengerIds.Info">
            <summary>
            获取信息
            </summary>
        </member>
        <member name="F:common.server.model.CounterMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.CryptoMessengerIds">
            <summary>
            加密相关信息
            </summary>
        </member>
        <member name="F:common.server.model.CryptoMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.CryptoMessengerIds.Key">
            <summary>
            获取key
            </summary>
        </member>
        <member name="F:common.server.model.CryptoMessengerIds.Set">
            <summary>
            设置秘钥
            </summary>
        </member>
        <member name="F:common.server.model.CryptoMessengerIds.Test">
            <summary>
            测试
            </summary>
        </member>
        <member name="F:common.server.model.CryptoMessengerIds.Clear">
            <summary>
            清除
            </summary>
        </member>
        <member name="F:common.server.model.CryptoMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.HeartMessengerIds">
            <summary>
            心跳相关消息id
            </summary>
        </member>
        <member name="F:common.server.model.HeartMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.HeartMessengerIds.Alive">
            <summary>
            活着
            </summary>
        </member>
        <member name="F:common.server.model.HeartMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.PunchHoleRequestInfo">
            <summary>
            打洞数据交换
            </summary>
        </member>
        <member name="M:common.server.model.PunchHoleRequestInfo.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.PunchForwardType">
            <summary>
            数据交换分两种，一种是a让服务器把a的公网数据发给b，另一种是，a把一些数据通过服务器原样交给b
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.PunchStep">
            <summary>
            打洞步骤，这个数据是第几步
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.PunchType">
            <summary>
            打洞类别，tcp udp 或者其它
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.Index">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.FromId">
            <summary>
            来自谁
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.ToId">
            <summary>
            给谁
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.TunnelName">
            <summary>
            通道名，可能会有多个通道
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.RequestId">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleRequestInfo.Data">
            <summary>
            携带的数
            </summary>
        </member>
        <member name="M:common.server.model.PunchHoleRequestInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.PunchHoleRequestInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.PunchHoleResponseInfo">
            <summary>
            打洞消息回执
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleResponseInfo.RequestId">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleResponseInfo.FromId">
            <summary>
            来自谁
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleResponseInfo.ToId">
            <summary>
            给谁
            </summary>
        </member>
        <member name="M:common.server.model.PunchHoleResponseInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.PunchHoleResponseInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.PunchForwardTypes">
            <summary>
            打洞消息类型
            </summary>
        </member>
        <member name="F:common.server.model.PunchForwardTypes.NOTIFY">
            <summary>
            通知
            </summary>
        </member>
        <member name="F:common.server.model.PunchForwardTypes.FORWARD">
            <summary>
            转发
            </summary>
        </member>
        <member name="T:common.server.model.PunchHoleNotifyInfo">
            <summary>
            打洞消息通知数据
            </summary>
        </member>
        <member name="M:common.server.model.PunchHoleNotifyInfo.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleNotifyInfo.LocalIps">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleNotifyInfo.IsDefault">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleNotifyInfo.Index">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleNotifyInfo.Ip">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleNotifyInfo.Port">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.PunchHoleNotifyInfo.LocalPort">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.model.PunchHoleNotifyInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.PunchHoleNotifyInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.PunchHoleMessengerIds">
            <summary>
            打洞相关消息id
            </summary>
        </member>
        <member name="F:common.server.model.PunchHoleMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.PunchHoleMessengerIds.Request">
            <summary>
            发送
            </summary>
        </member>
        <member name="F:common.server.model.PunchHoleMessengerIds.Response">
            <summary>
            回执
            </summary>
        </member>
        <member name="F:common.server.model.PunchHoleMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.RegisterParamsInfo">
            <summary>
            客户端注册数据
            </summary>
        </member>
        <member name="M:common.server.model.RegisterParamsInfo.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.LocalIps">
            <summary>
            本地ip，loopback 、LAN ip
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.Id">
            <summary>
            连接id，因为分两次注册，第二次带上第一次的注册后获得的id
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.ShortId">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.GroupId">
            <summary>
            分组
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.LocalTcpPort">
            <summary>
            本机tcp端口
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.LocalUdpPort">
            <summary>
            本机udp端口
            </summary>
        </member>
        <member name="P:common.server.model.RegisterParamsInfo.ClientAccess">
            <summary>
            客户端自定义的权限列表
            </summary>
        </member>
        <member name="M:common.server.model.RegisterParamsInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.RegisterParamsInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.RegisterResultInfo">
            <summary>
            客户端注册服务器返回的数据
            </summary>
        </member>
        <member name="M:common.server.model.RegisterResultInfo.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.Code">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.Relay">
            <summary>
            服务器是否支持中继
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.UdpPort">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.TcpPort">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.Id">
            <summary>
            连接id
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.ShortId">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.Ip">
            <summary>
            连接ip
            </summary>
        </member>
        <member name="P:common.server.model.RegisterResultInfo.GroupId">
            <summary>
            连接分组
            </summary>
        </member>
        <member name="M:common.server.model.RegisterResultInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.RegisterResultInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.RegisterResultInfo.RegisterResultInfoCodes">
            <summary>
            注册结果类别
            </summary>
        </member>
        <member name="F:common.server.model.RegisterResultInfo.RegisterResultInfoCodes.OK">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RegisterResultInfo.RegisterResultInfoCodes.SAME_NAMES">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RegisterResultInfo.RegisterResultInfoCodes.SAME_SHORTID">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RegisterResultInfo.RegisterResultInfoCodes.ERROR_SHORTID">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RegisterResultInfo.RegisterResultInfoCodes.VERIFY">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RegisterResultInfo.RegisterResultInfoCodes.KEY_VERIFY">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RegisterResultInfo.RegisterResultInfoCodes.UNKNOW">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.TunnelRegisterInfo">
            <summary>
            端口注册
            </summary>
        </member>
        <member name="M:common.server.model.TunnelRegisterInfo.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.TunnelRegisterInfo.TunnelName">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.TunnelRegisterInfo.LocalPort">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.TunnelRegisterInfo.Port">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.model.TunnelRegisterInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.TunnelRegisterInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.TunnelDefaults">
            <summary>
            通道默认值
            </summary>
        </member>
        <member name="F:common.server.model.TunnelDefaults.MIN">
            <summary>
            使用此值，则生成新的值
            </summary>
        </member>
        <member name="F:common.server.model.TunnelDefaults.UDP">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.TunnelDefaults.TCP">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.TunnelDefaults.MAX">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.RegisterMessengerIds">
            <summary>
            注册相关的消息id
            </summary>
        </member>
        <member name="F:common.server.model.RegisterMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RegisterMessengerIds.SignIn">
            <summary>
            注册
            </summary>
        </member>
        <member name="F:common.server.model.RegisterMessengerIds.Notify">
            <summary>
            通知
            </summary>
        </member>
        <member name="F:common.server.model.RegisterMessengerIds.SignOut">
            <summary>
            退出
            </summary>
        </member>
        <member name="F:common.server.model.RegisterMessengerIds.GetSetting">
            <summary>
            获取配置
            </summary>
        </member>
        <member name="F:common.server.model.RegisterMessengerIds.Setting">
            <summary>
            配置
            </summary>
        </member>
        <member name="F:common.server.model.RegisterMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.RelayInfo">
            <summary>
            中继
            </summary>
        </member>
        <member name="P:common.server.model.RelayInfo.Connection">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.RelayInfo.RelayIds">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.model.RelayInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.RelayInfo.DeBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:common.server.model.RelayMessengerIds">
            <summary>
            中继相关消息id
            </summary>
        </member>
        <member name="F:common.server.model.RelayMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.RelayMessengerIds.Relay">
            <summary>
            中继
            </summary>
        </member>
        <member name="F:common.server.model.RelayMessengerIds.Delay">
            <summary>
            延迟
            </summary>
        </member>
        <member name="F:common.server.model.RelayMessengerIds.AskConnects">
            <summary>
            请求连接信息
            </summary>
        </member>
        <member name="F:common.server.model.RelayMessengerIds.Connects">
            <summary>
            回复连接信息
            </summary>
        </member>
        <member name="F:common.server.model.RelayMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.ConnectsInfo">
            <summary>
            连接信息
            </summary>
        </member>
        <member name="P:common.server.model.ConnectsInfo.Id">
            <summary>
            我
            </summary>
        </member>
        <member name="P:common.server.model.ConnectsInfo.ToId">
            <summary>
            给谁
            </summary>
        </member>
        <member name="P:common.server.model.ConnectsInfo.Connects">
            <summary>
            我连了谁
            </summary>
        </member>
        <member name="M:common.server.model.ConnectsInfo.ReadToId(System.Memory{System.Byte})">
            <summary>
            
            </summary>
            <param name="memory"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.model.ConnectsInfo.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.ConnectsInfo.DeBytes(System.Memory{System.Byte})">
            <summary>
            
            </summary>
            <param name="memory"></param>
        </member>
        <member name="T:common.server.model.MessageRequestWrap">
            <summary>
            请求消息包
            </summary>
        </member>
        <member name="F:common.server.model.MessageRequestWrap.RelayIdLengthPos">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageRequestWrap.RelayIdIndexPos">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageRequestWrap.RelayIdSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageRequestWrap.RelayBit">
            <summary>
            Relay + Reply + 111111
            </summary>
        </member>
        <member name="F:common.server.model.MessageRequestWrap.ReplyBit">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageRequestWrap.TypeBits">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.Connection">
            <summary>
            用来读取数据，发送数据用下一层的FromConnection，来源连接，在中继时，数据来自服务器，但是真实来源是别的客户端，所以不能直接用这个来发送回复的数据
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.Timeout">
            <summary>
            超时时间，发送待回复时设置
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.MessengerId">
            <summary>
            消息id
            </summary>
        </member>
        <member name="F:common.server.model.MessageRequestWrap.RequestId">
            <summary>
            每条数据都有个id，【只发发数据的话，不用填这里】
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.Reply">
            <summary>
            是否等待回复
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.Relay">
            <summary>
            是否中继
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.RelayId">
            <summary>
            中继节点id列表
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.RelayIds">
            <summary>
            中继节点id列表，读取用
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.RelayIdLength">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.RelayIdIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageRequestWrap.Payload">
            <summary>
            数据荷载
            </summary>
        </member>
        <member name="M:common.server.model.MessageRequestWrap.ToArray(System.Int32@)">
            <summary>
            转包
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.MessageRequestWrap.FromArray(System.Memory{System.Byte})">
            <summary>
            解包
            </summary>
            <param name="memory"></param>
        </member>
        <member name="M:common.server.model.MessageRequestWrap.Return(System.Byte[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="T:common.server.model.MessageResponseWrap">
            <summary>
            回执消息包
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.Connection">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.Code">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.RequestId">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.RelayIds">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.RelayIdLength">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.RelayIdIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.Payload">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.model.MessageResponseWrap.Relay">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.model.MessageResponseWrap.ToArray(System.Int32@)">
            <summary>
            转包
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.model.MessageResponseWrap.FromArray(System.Memory{System.Byte})">
            <summary>
            解包
            </summary>
            <param name="memory"></param>
        </member>
        <member name="M:common.server.model.MessageResponseWrap.Return(System.Byte[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:common.server.model.MessageResponseWrap.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.MessageResponeCodes">
            <summary>
            消息状态
            </summary>
        </member>
        <member name="F:common.server.model.MessageResponeCodes.OK">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageResponeCodes.NOT_CONNECT">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageResponeCodes.NOT_FOUND">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageResponeCodes.TIMEOUT">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageResponeCodes.ERROR">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.MessageTypes">
            <summary>
            消息类别
            </summary>
        </member>
        <member name="F:common.server.model.MessageTypes.REQUEST">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.MessageTypes.RESPONSE">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.ServerType">
            <summary>
            服务类型
            </summary>
        </member>
        <member name="F:common.server.model.ServerType.TCP">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.ServerType.UDP">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.ServerType.TCPUDP">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.model.EnumServiceAccess">
            <summary>
            服务端的各项服务权限
            </summary>
        </member>
        <member name="F:common.server.model.EnumServiceAccess.Register">
            <summary>
            注册
            </summary>
        </member>
        <member name="F:common.server.model.EnumServiceAccess.Relay">
            <summary>
            中继
            </summary>
        </member>
        <member name="F:common.server.model.EnumServiceAccess.TcpForward">
            <summary>
            tcp转发
            </summary>
        </member>
        <member name="F:common.server.model.EnumServiceAccess.UdpForward">
            <summary>
            udp转发
            </summary>
        </member>
        <member name="F:common.server.model.EnumServiceAccess.Socks5">
            <summary>
            socks5
            </summary>
        </member>
        <member name="F:common.server.model.EnumServiceAccess.Setting">
            <summary>
            配置
            </summary>
        </member>
        <member name="T:common.server.model.ServiceAccessValidatorMessengerIds">
            <summary>
            权限相关的消息id
            </summary>
        </member>
        <member name="F:common.server.model.ServiceAccessValidatorMessengerIds.Min">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.model.ServiceAccessValidatorMessengerIds.GetSetting">
            <summary>
            获取配置
            </summary>
        </member>
        <member name="F:common.server.model.ServiceAccessValidatorMessengerIds.Setting">
            <summary>
            配置
            </summary>
        </member>
        <member name="F:common.server.model.ServiceAccessValidatorMessengerIds.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.iocp.BufferManager">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.BufferManager.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="totalBytes"></param>
            <param name="bufferSize"></param>
        </member>
        <member name="M:common.server.servers.iocp.BufferManager.InitBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.BufferManager.SetBuffer(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.servers.iocp.SocketAsyncEventArgsPool">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.SocketAsyncEventArgsPool.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:common.server.servers.iocp.SocketAsyncEventArgsPool.Push(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:common.server.servers.iocp.SocketAsyncEventArgsPool.Pop">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:common.server.servers.iocp.SocketAsyncEventArgsPool.Count">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.iocp.TcpServer">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.TcpServer.OnPacket">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.TcpServer.OnDisconnect">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.TcpServer.OnConnected">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.TcpServer.OnConnected1">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.SetBufferSize(System.Int32)">
            <summary>
            
            </summary>
            <param name="bufferSize"></param>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.Start1(System.Int32)">
            <summary>
            
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.Start(System.Int32)">
            <summary>
            
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.BindReceive(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.CreateConnection(System.Net.Sockets.Socket)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.Disponse">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.TcpServer.InputData(common.server.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.servers.iocp.AsyncUserToken">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.AsyncUserToken.Connection">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.AsyncUserToken.Socket">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.AsyncUserToken.DataBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.AsyncUserToken.Port">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.iocp.AsyncUserToken.PoolBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.iocp.AsyncUserToken.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.pipeLine.PipelineClient">
            <summary>
            具名管道客户端
            </summary>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineClient.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="pipeName"></param>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineClient.Connect">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineClient.WriteLine(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineClient.ReadLine">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineClient.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.pipeLine.PipelineServer">
            <summary>
            具名管道服务端
            </summary>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineServer.#ctor(System.String,System.Func{System.String,System.String})">
            <summary>
            
            </summary>
            <param name="pipeName"></param>
            <param name="action"></param>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineServer.BeginAccept">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.pipeLine.PipelineServer.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.rudp.UdpServer">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.rudp.UdpServer.OnPacket">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.rudp.UdpServer.OnDisconnect">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.rudp.UdpServer.OnConnected">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.Start(System.Int32)">
            <summary>
            
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.Start(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="port"></param>
            <param name="timeout"></param>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.Disponse">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.InputData(common.server.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.CreateConnection(System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.SendUnconnectedMessage(System.Byte[],System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.rudp.UdpServer.SetSpeedLimit(System.Int32)">
            <summary>
            
            </summary>
            <param name="limit"></param>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketClient">
            <summary>
            wensocket客户端
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnConnecting">
            <summary>
            连接中，false表示失败，会关闭连接
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketClient.OnConnectFail">
            <summary>
            连接失败
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnDisConnectd">
            <summary>
            已断开连接,未收到关闭帧
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnOpen">
            <summary>
            已连接
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnClose">
            <summary>
            已断开连接,收到关闭帧
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnMessage">
            <summary>
            文本数据
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnBinary">
            <summary>
            二进制数据
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnControll">
            <summary>
            控制帧
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketClient.OnUnControll">
            <summary>
            非控制帧
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.Connect(System.Net.IPAddress,System.Int32)">
            <summary>
            
            </summary>
            <param name="ip"></param>
            <param name="port"></param>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.Connect(System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="ep"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.Close">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendRaw(System.Byte[])">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendFrame(common.server.servers.websocket.WebSocketFrameRemarkInfo)">
            <summary>
            
            </summary>
            <param name="remark"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendFrameText(System.String)">
            <summary>
            
            </summary>
            <param name="txt"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendFrameText(System.Byte[])">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendFrameBinary(System.Byte[])">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendFramePoing">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendFramePong">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.SendFrameClose(common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus)">
            <summary>
            
            </summary>
            <param name="status"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketClient.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.AsyncServerUserToken">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncServerUserToken.TargetSocket">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.AsyncServerUserToken.FrameInfo">
            <summary>
            当前帧数据
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncServerUserToken.FrameIndex">
            <summary>
            当前帧的数据下标
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncServerUserToken.FrameBuffer">
            <summary>
            数据帧缓存
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncServerUserToken.Opcode">
            <summary>
            当前帧的数据类型
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncServerUserToken.SecWebSocketKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncServerUserToken.PoolBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.AsyncServerUserToken.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketParser">
            <summary>
            websocket解析器
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildConnectData(common.server.servers.websocket.WebsocketHeaderInfo)">
            <summary>
            构建连接数据
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildConnectResponseData(common.server.servers.websocket.WebsocketHeaderInfo)">
            <summary>
            构建连接回应数据
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildSecWebSocketKey">
            <summary>
            生成随机key
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildMaskKey">
            <summary>
            构建mask数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildSecWebSocketAccept(System.Memory{System.Byte})">
            <summary>
            生成accept回应
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.VerifySecWebSocketAccept(System.Memory{System.Byte},System.Memory{System.Byte})">
            <summary>
            验证回应的accept
            </summary>
            <param name="key"></param>
            <param name="accept"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildPingData">
            <summary>
            构建ping帧
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildPongData">
            <summary>
            构建pong帧
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.BuildFrameData(common.server.servers.websocket.WebSocketFrameRemarkInfo)">
            <summary>
            构建数据帧
            </summary>
            <param name="remark"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketParser.AddSpace(System.Net.HttpStatusCode)">
            <summary>
            给每个大写字母前加一个空格，例如ProxyAuthenticationRequired 变成Proxy Authentication Required
            </summary>
            <param name="statusCode"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameRemarkInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.Fin">
            <summary>
            是否是结束帧，如果只有一帧，那必定是结束帧
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.Rsv1">
            <summary>
            保留位1
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.Rsv2">
            <summary>
            保留位2
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.Rsv3">
            <summary>
            保留位3
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.Opcode">
            <summary>
            数据描述，默认TEXT数据
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.Mask">
            <summary>
            是否有掩码
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.MaskData">
            <summary>
            掩码key 4字节
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameRemarkInfo.Data">
            <summary>
            payload data
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo">
            <summary>
            数据帧解析
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.Fin">
            <summary>
            是否是结束帧
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.Rsv1">
            <summary>
            保留位
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.Rsv2">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.Rsv3">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.Opcode">
            <summary>
            操作码 0附加数据，1文本，2二进制，3-7为非控制保留，8关闭，9ping，a pong，b-f 为控制保留
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.Mask">
            <summary>
            掩码
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.TotalLength">
            <summary>
            总长度
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketFrameInfo.PayloadData">
            <summary>
            数据 如果OPCODE是 EnumOpcode.Close 则数据的前2字节为关闭状态码，余下的为其它描述数据
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketFrameInfo.TryParse(System.Memory{System.Byte},common.server.servers.websocket.WebSocketFrameInfo@)">
            <summary>
            解析帧，如果false解析失败，则应该把data缓存起来，等待下次来数据后，拼接起来再次解析
            </summary>
            <param name="data"></param>
            <param name="frameInfo"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo.EnumFin">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumFin.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumFin.Fin">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo.EnumMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumMask.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumMask.Mask">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv1">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv1.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv1.Rsv">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv2">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv2.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv2.Rsv">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv3">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv3.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumRsv3.Rsv">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Data">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Text">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Binary">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.UnControll3">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.UnControll4">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.UnControll5">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.UnControll6">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.UnControll7">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Close">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Ping">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Pong">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Controll11">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Controll12">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Controll13">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Controll14">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Controll15">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumOpcode.Last">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus">
            <summary>
            关闭的状态码
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.Normal">
            <summary>
            正常关闭
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.Leaving">
            <summary>
            正在离开
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.ProtocolError">
            <summary>
            协议错误
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.TextOnly">
            <summary>
            只能接收TEXT数据
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.None1004">
            <summary>
            保留
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.None1005">
            <summary>
            保留
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.None1006">
            <summary>
            保留
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.DataTypeError">
            <summary>
            消息类型不一致
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.PublicError">
            <summary>
            通用状态码，没有别的合适的状态码时，用这个
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.DataTooBig">
            <summary>
            数据太大，无法处理
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.ExtendsError">
            <summary>
            扩展错误
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.Unexpected">
            <summary>
            意外情况
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus.TLSError">
            <summary>
            TLS握手失败
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.WebsocketHeaderInfo">
            <summary>
            请求头解析
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.StatusCode">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.Method">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.PathSet">
            <summary>
            用这个设置path值
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.Path">
            <summary>
            如果 仅1个字符，那就是 /
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.Connection">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.Upgrade">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.Origin">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.SecWebSocketVersion">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.SecWebSocketKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.SecWebSocketExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.SecWebSocketProtocol">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketHeaderInfo.SecWebSocketAccept">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketHeaderInfo.Parse(System.Memory{System.Byte})">
            <summary>
            
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="T:common.server.servers.websocket.WebSocketServer">
            <summary>
            websocket服务端
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnConnecting">
            <summary>
            收到连接，可以在这处理 subProtocol extensions 及其它信息，false表示阻止连接，应设置header 的 StatusCode
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnDisConnectd">
            <summary>
            已断开连接，没有收到关闭帧
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnOpen">
            <summary>
            已连接
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnClose">
            <summary>
            已关闭，收到关闭帧
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnMessage">
            <summary>
            文本数据
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnBinary">
            <summary>
            二进制数据
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnControll">
            <summary>
            控制帧，保留的控制帧，可以自定义处理
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.WebSocketServer.OnUnControll">
            <summary>
            非控制帧，保留的非控制帧，可以自定义处理
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebSocketServer.Connections">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketServer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketServer.Start(System.Net.IPAddress,System.Int32)">
            <summary>
            
            </summary>
            <param name="bindip"></param>
            <param name="port"></param>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketServer.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebSocketServer.ReadFrame(common.server.servers.websocket.AsyncUserToken,System.Memory{System.Byte})">
            <summary>
            读取数据帧，分帧、粘包、半包处理，得到完整的包再根据opcode交给对应的处理
            </summary>
            <param name="token"></param>
            <param name="data"></param>
        </member>
        <member name="T:common.server.servers.websocket.WebsocketConnection">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketConnection.Id">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketConnection.Socket">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.WebsocketConnection.Connected">
            <summary>
            
            </summary>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.ConnectResponse(common.server.servers.websocket.WebsocketHeaderInfo)">
            <summary>
            
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.SendRaw(System.Byte[])">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.SendFrame(common.server.servers.websocket.WebSocketFrameRemarkInfo)">
            <summary>
            
            </summary>
            <param name="remark"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.SendFrameText(System.String)">
            <summary>
            
            </summary>
            <param name="txt"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.SendFrameText(System.Byte[])">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.SendFrameBinary(System.Byte[])">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.SendFramePong">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.SendFrameClose(common.server.servers.websocket.WebSocketFrameInfo.EnumCloseStatus)">
            <summary>
            
            </summary>
            <param name="status"></param>
            <returns></returns>
        </member>
        <member name="M:common.server.servers.websocket.WebsocketConnection.Close">
            <summary>
            
            </summary>
        </member>
        <member name="T:common.server.servers.websocket.AsyncUserToken">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncUserToken.Connectrion">
            <summary>
            
            </summary>
        </member>
        <member name="F:common.server.servers.websocket.AsyncUserToken.FrameInfo">
            <summary>
            当前帧数据
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncUserToken.FrameIndex">
            <summary>
            当前帧的数据下标
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncUserToken.FrameBuffer">
            <summary>
            数据帧缓存
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncUserToken.Opcode">
            <summary>
            当前帧的数据类型
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncUserToken.PoolBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="P:common.server.servers.websocket.AsyncUserToken.Disposabled">
             <summary>
            
             </summary>
        </member>
        <member name="M:common.server.servers.websocket.AsyncUserToken.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="T:LiteNetLib.ConnectionRequest">
            <summary>
            
            </summary>
        </member>
        <member name="P:LiteNetLib.ConnectionRequest.Data">
            <summary>
            
            </summary>
        </member>
        <member name="F:LiteNetLib.ConnectionRequest.RemoteEndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.AcceptIfKey(System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.Accept">
            <summary>
            Accept connection and get new NetPeer as result
            </summary>
            <returns>Connected NetPeer</returns>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.Reject(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="rejectData"></param>
            <param name="start"></param>
            <param name="length"></param>
            <param name="force"></param>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.Reject(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rejectData"></param>
            <param name="start"></param>
            <param name="length"></param>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.RejectForce(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rejectData"></param>
            <param name="start"></param>
            <param name="length"></param>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.RejectForce">
            <summary>
            
            </summary>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.RejectForce(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rejectData"></param>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.RejectForce(LiteNetLib.Utils.NetDataWriter)">
            <summary>
            
            </summary>
            <param name="rejectData"></param>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.Reject">
            <summary>
            
            </summary>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.Reject(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rejectData"></param>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.Reject(LiteNetLib.Utils.NetDataWriter)">
            <summary>
            
            </summary>
            <param name="rejectData"></param>
        </member>
        <member name="T:LiteNetLib.UnconnectedMessageType">
            <summary>
            Type of message that you receive in OnNetworkReceiveUnconnected event
            </summary>
        </member>
        <member name="T:LiteNetLib.DisconnectReason">
            <summary>
            Disconnect reason that you receive in OnPeerDisconnected event
            </summary>
        </member>
        <member name="T:LiteNetLib.DisconnectInfo">
            <summary>
            Additional information about disconnection
            </summary>
        </member>
        <member name="F:LiteNetLib.DisconnectInfo.Reason">
            <summary>
            Additional info why peer disconnected
            </summary>
        </member>
        <member name="F:LiteNetLib.DisconnectInfo.SocketErrorCode">
            <summary>
            Error code (if reason is SocketSendError or SocketReceiveError)
            </summary>
        </member>
        <member name="F:LiteNetLib.DisconnectInfo.AdditionalData">
            <summary>
            Additional data that can be accessed (only if reason is RemoteConnectionClose)
            </summary>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnPeerConnected(LiteNetLib.NetPeer)">
            <summary>
            New remote peer connected to host, or client connected to remote host
            </summary>
            <param name="peer">Connected peer object</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnPeerDisconnected(LiteNetLib.NetPeer,LiteNetLib.DisconnectInfo)">
            <summary>
            Peer disconnected
            </summary>
            <param name="peer">disconnected peer</param>
            <param name="disconnectInfo">additional info about reason, errorCode or data received with disconnect message</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkError(System.Net.IPEndPoint,System.Net.Sockets.SocketError)">
            <summary>
            Network error (on send or receive)
            </summary>
            <param name="endPoint">From endPoint (can be null)</param>
            <param name="socketError">Socket error</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkReceive(LiteNetLib.NetPeer,LiteNetLib.NetPacketReader,System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Received some data
            </summary>
            <param name="peer">From peer</param>
            <param name="reader">DataReader containing all received data</param>
            <param name="channelNumber">Number of channel at which packet arrived</param>
            <param name="deliveryMethod">Type of received packet</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkReceiveUnconnected(System.Net.IPEndPoint,LiteNetLib.NetPacketReader,LiteNetLib.UnconnectedMessageType)">
            <summary>
            Received unconnected message
            </summary>
            <param name="remoteEndPoint">From address (IP and Port)</param>
            <param name="reader">Message data</param>
            <param name="messageType">Message type (simple, discovery request or response)</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkLatencyUpdate(LiteNetLib.NetPeer,System.Int32)">
            <summary>
            Latency information updated
            </summary>
            <param name="peer">Peer with updated latency</param>
            <param name="latency">latency value in milliseconds</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnConnectionRequest(LiteNetLib.ConnectionRequest)">
            <summary>
            On peer connection requested
            </summary>
            <param name="request">Request information (EndPoint, internal id, additional data)</param>
        </member>
        <member name="M:LiteNetLib.IDeliveryEventListener.OnMessageDelivered(LiteNetLib.NetPeer,System.Object)">
            <summary>
            On reliable message delivered
            </summary>
            <param name="peer"></param>
            <param name="userData"></param>
        </member>
        <member name="M:LiteNetLib.INtpEventListener.OnNtpResponse(LiteNetLib.Utils.NtpPacket)">
            <summary>
            Ntp response
            </summary>
            <param name="packet"></param>
        </member>
        <member name="M:LiteNetLib.IPeerAddressChangedListener.OnPeerAddressChanged(LiteNetLib.NetPeer,System.Net.IPEndPoint)">
            <summary>
            Called when peer address changed (when AllowPeerAddressChange is enabled)
            </summary>
            <param name="peer">Peer that changed address (with new address)</param>
            <param name="previousAddress">previous IP</param>
        </member>
        <member name="T:LiteNetLib.NatPunchModule">
            <summary>
            Module for UDP NAT Hole punching operations. Can be accessed from NetManager
            </summary>
        </member>
        <member name="F:LiteNetLib.NatPunchModule.UnsyncedEvents">
            <summary>
            Events automatically will be called without PollEvents method from another thread
            </summary>
        </member>
        <member name="T:LiteNetLib.DeliveryMethod">
            <summary>
            Sending method type
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.Unreliable">
            <summary>
            Unreliable. Packets can be dropped, can be duplicated, can arrive without order.
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.ReliableUnordered">
            <summary>
            Reliable. Packets won't be dropped, won't be duplicated, can arrive without order.
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.Sequenced">
            <summary>
            Unreliable. Packets can be dropped, won't be duplicated, will arrive in order.
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.ReliableOrdered">
            <summary>
            Reliable and ordered. Packets won't be dropped, won't be duplicated, will arrive in order.
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.ReliableSequenced">
            <summary>
            Reliable only last packet. Packets can be dropped (except the last one), won't be duplicated, will arrive in order.
            Cannot be fragmented
            </summary>
        </member>
        <member name="T:LiteNetLib.NetConstants">
            <summary>
            Network constants. Can be tuned from sources for your purposes.
            </summary>
        </member>
        <member name="T:LiteNetLib.INetLogger">
            <summary>
            Interface to implement for your own logger
            </summary>
        </member>
        <member name="T:LiteNetLib.NetDebug">
            <summary>
            Static class for defining your own LiteNetLib logger instead of Console.WriteLine
            or Debug.Log if compiled with UNITY flag
            </summary>
        </member>
        <member name="T:LiteNetLib.NetManager">
            <summary>
            Main class for all network operations. Can be used as client and/or server.
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UnconnectedMessagesEnabled">
            <summary>
            Enable messages receiving without connection. (with SendUnconnectedMessage method)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.NatPunchEnabled">
            <summary>
            Enable nat punch messages
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UpdateTime">
            <summary>
            Library logic update and send period in milliseconds
            Lowest values in Windows doesn't change much because of Thread.Sleep precision
            To more frequent sends (or sends tied to your game logic) use <see cref="M:LiteNetLib.NetManager.TriggerUpdate"/>
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.PingInterval">
            <summary>
            Interval for latency detection and checking connection (in milliseconds)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.DisconnectTimeout">
            <summary>
            If NetManager doesn't receive any packet from remote peer during this time (in milliseconds) then connection will be closed
            (including library internal keepalive packets)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulatePacketLoss">
            <summary>
            Simulate packet loss by dropping random amount of packets. (Works only in DEBUG mode)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulateLatency">
            <summary>
            Simulate latency by holding packets for random time. (Works only in DEBUG mode)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulationPacketLossChance">
            <summary>
            Chance of packet loss when simulation enabled. value in percents (1 - 100).
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulationMinLatency">
            <summary>
            Minimum simulated latency (in milliseconds)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulationMaxLatency">
            <summary>
            Maximum simulated latency (in milliseconds)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UnsyncedEvents">
            <summary>
            Events automatically will be called without PollEvents method from another thread
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UnsyncedReceiveEvent">
            <summary>
            If true - receive event will be called from "receive" thread immediately otherwise on PollEvents call
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UnsyncedDeliveryEvent">
            <summary>
            If true - delivery event will be called from "receive" thread immediately otherwise on PollEvents call
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.BroadcastReceiveEnabled">
            <summary>
            Allows receive broadcast packets
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.ReconnectDelay">
            <summary>
            Delay between initial connection attempts (in milliseconds)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.MaxConnectAttempts">
            <summary>
            Maximum connection attempts before client stops and call disconnect event.
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.ReuseAddress">
            <summary>
            Enables socket option "ReuseAddress" for specific purposes
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.Statistics">
            <summary>
            Statistics of all connections
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.EnableStatistics">
            <summary>
            Toggles the collection of network statistics for the instance and all known peers
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.NatPunchModule">
            <summary>
            NatPunchModule for NAT hole punching operations
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.IsRunning">
            <summary>
            Returns true if socket listening and update thread is running
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.LocalPort">
            <summary>
            Local EndPoint (host and port)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.AutoRecycle">
            <summary>
            Automatically recycle NetPacketReader after OnReceive event
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.IPv6Mode">
            <summary>
            IPv6 support
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.MtuOverride">
            <summary>
            Override MTU for all new peers registered in this NetManager, will ignores MTU Discovery!
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UseSafeMtu">
            <summary>
            Sets initial MTU to lowest possible value according to RFC1191 (576 bytes)
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.FirstPeer">
            <summary>
            First peer. Useful for Client mode
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UseNativeSockets">
            <summary>
            Experimental feature mostly for servers. Only for Windows/Linux
            use direct socket calls for send/receive to drastically increase speed and reduce GC pressure
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.DisconnectOnUnreachable">
            <summary>
            Disconnect peers if HostUnreachable or NetworkUnreachable spawned (old behaviour 0.9.x was true)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.AllowPeerAddressChange">
            <summary>
            Allows peer change it's ip (lte to wifi, wifi to lte, etc). Use only on server
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.ChannelsCount">
            <summary>
            QoS channel count per message type (value must be between 1 and 64 channels)
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.ConnectedPeerList">
            <summary>
            Returns connected peers list (with internal cached list)
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.GetPeerById(System.Int32)">
            <summary>
            Gets peer by peer id
            </summary>
            <param name="id">id of peer</param>
            <returns>Peer if peer with id exist, otherwise null</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.TryGetPeerById(System.Int32,LiteNetLib.NetPeer@)">
            <summary>
            Gets peer by peer id
            </summary>
            <param name="id">id of peer</param>
            <param name="peer">resulting peer</param>
            <returns>True if peer with id exist, otherwise false</returns>
        </member>
        <member name="P:LiteNetLib.NetManager.ConnectedPeersCount">
            <summary>
            Returns connected peers count
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.#ctor(LiteNetLib.INetEventListener,LiteNetLib.Layers.PacketLayerBase)">
            <summary>
            NetManager constructor
            </summary>
            <param name="listener">Network events listener (also can implement IDeliveryEventListener)</param>
            <param name="extraPacketLayer">Extra processing of packages, like CRC checksum or encryption. All connected NetManagers must have same layer.</param>
        </member>
        <member name="M:LiteNetLib.NetManager.ManualUpdate(System.Int32)">
            <summary>
            Update and send logic. Use this only when NetManager started in manual mode
            </summary>
            <param name="elapsedMilliseconds">elapsed milliseconds since last update call</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(LiteNetLib.Utils.NetDataWriter,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers (channel - 0)
            </summary>
            <param name="writer">DataWriter with data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers (channel - 0)
            </summary>
            <param name="data">Data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Int32,System.Int32,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers (channel - 0)
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(LiteNetLib.Utils.NetDataWriter,System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="writer">DataWriter with data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Int32,System.Int32,System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(LiteNetLib.Utils.NetDataWriter,LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers (channel - 0)
            </summary>
            <param name="writer">DataWriter with data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers (channel - 0)
            </summary>
            <param name="data">Data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Int32,System.Int32,LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers (channel - 0)
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(LiteNetLib.Utils.NetDataWriter,System.Byte,LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="writer">DataWriter with data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Byte,LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Int32,System.Int32,System.Byte,LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.Start">
            <summary>
            Start logic thread and listening on available port
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.Start(System.Net.IPAddress,System.Net.IPAddress,System.Int32)">
            <summary>
            Start logic thread and listening on selected port
            </summary>
            <param name="addressIPv4">bind to specific ipv4 address</param>
            <param name="addressIPv6">bind to specific ipv6 address</param>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.Start(System.String,System.String,System.Int32)">
            <summary>
            Start logic thread and listening on selected port
            </summary>
            <param name="addressIPv4">bind to specific ipv4 address</param>
            <param name="addressIPv6">bind to specific ipv6 address</param>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.Start(System.Int32)">
            <summary>
            Start logic thread and listening on selected port
            </summary>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.StartInManualMode(System.Net.IPAddress,System.Net.IPAddress,System.Int32)">
            <summary>
            Start in manual mode and listening on selected port
            In this mode you should use ManualReceive (without PollEvents) for receive packets
            and ManualUpdate(...) for update and send packets
            This mode useful mostly for single-threaded servers
            </summary>
            <param name="addressIPv4">bind to specific ipv4 address</param>
            <param name="addressIPv6">bind to specific ipv6 address</param>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.StartInManualMode(System.String,System.String,System.Int32)">
            <summary>
            Start in manual mode and listening on selected port
            In this mode you should use ManualReceive (without PollEvents) for receive packets
            and ManualUpdate(...) for update and send packets
            This mode useful mostly for single-threaded servers
            </summary>
            <param name="addressIPv4">bind to specific ipv4 address</param>
            <param name="addressIPv6">bind to specific ipv6 address</param>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.StartInManualMode(System.Int32)">
            <summary>
            Start in manual mode and listening on selected port
            In this mode you should use ManualReceive (without PollEvents) for receive packets
            and ManualUpdate(...) for update and send packets
            This mode useful mostly for single-threaded servers
            </summary>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendUnconnectedMessage(System.Byte[],System.Net.IPEndPoint)">
            <summary>
            Send message without connection
            </summary>
            <param name="message">Raw data</param>
            <param name="remoteEndPoint">Packet destination</param>
            <returns>Operation result</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.SendUnconnectedMessage(LiteNetLib.Utils.NetDataWriter,System.String,System.Int32)">
            <summary>
            Send message without connection. WARNING This method allocates a new IPEndPoint object and
            synchronously makes a DNS request. If you're calling this method every frame it will be
            much faster to just cache the IPEndPoint.
            </summary>
            <param name="writer">Data serializer</param>
            <param name="address">Packet destination IP or hostname</param>
            <param name="port">Packet destination port</param>
            <returns>Operation result</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.SendUnconnectedMessage(LiteNetLib.Utils.NetDataWriter,System.Net.IPEndPoint)">
            <summary>
            Send message without connection
            </summary>
            <param name="writer">Data serializer</param>
            <param name="remoteEndPoint">Packet destination</param>
            <returns>Operation result</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.SendUnconnectedMessage(System.Byte[],System.Int32,System.Int32,System.Net.IPEndPoint)">
            <summary>
            Send message without connection
            </summary>
            <param name="message">Raw data</param>
            <param name="start">data start</param>
            <param name="length">data length</param>
            <param name="remoteEndPoint">Packet destination</param>
            <returns>Operation result</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.TriggerUpdate">
            <summary>
            Triggers update and send logic immediately (works asynchronously)
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.PollEvents">
            <summary>
            Receive all pending events. Call this in game update code
            In Manual mode it will call also socket Receive (which can be slow)
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.String,System.Int32,System.String)">
            <summary>
            Connect to remote host
            </summary>
            <param name="address">Server IP or hostname</param>
            <param name="port">Server Port</param>
            <param name="key">Connection key</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.String,System.Int32,LiteNetLib.Utils.NetDataWriter)">
            <summary>
            Connect to remote host
            </summary>
            <param name="address">Server IP or hostname</param>
            <param name="port">Server Port</param>
            <param name="connectionData">Additional data for remote peer</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.Net.IPEndPoint,System.String)">
            <summary>
            Connect to remote host
            </summary>
            <param name="target">Server end point (ip and port)</param>
            <param name="key">Connection key</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.Net.IPEndPoint,LiteNetLib.Utils.NetDataWriter)">
            <summary>
            Connect to remote host
            </summary>
            <param name="target">Server end point (ip and port)</param>
            <param name="connectionData">Additional data for remote peer</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Stop">
            <summary>
            Force closes connection and stop all threads.
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.Stop(System.Boolean)">
            <summary>
            Force closes connection and stop all threads.
            </summary>
            <param name="sendDisconnectMessages">Send disconnect messages</param>
        </member>
        <member name="M:LiteNetLib.NetManager.GetPeersCount(LiteNetLib.ConnectionState)">
            <summary>
            Return peers count with connection state
            </summary>
            <param name="peerState">peer connection state (you can use as bit flags)</param>
            <returns>peers count</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.GetPeersNonAlloc(System.Collections.Generic.List{LiteNetLib.NetPeer},LiteNetLib.ConnectionState)">
            <summary>
            Get copy of peers (without allocations)
            </summary>
            <param name="peers">List that will contain result</param>
            <param name="peerState">State of peers</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectAll">
            <summary>
            Disconnect all peers without any additional data
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectAll(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Disconnect all peers with shutdown message
            </summary>
            <param name="data">Data to send (must be less or equal MTU)</param>
            <param name="start">Data start</param>
            <param name="count">Data count</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeerForce(LiteNetLib.NetPeer)">
            <summary>
            Immediately disconnect peer from server without additional data
            </summary>
            <param name="peer">peer to disconnect</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer)">
            <summary>
            Disconnect peer from server
            </summary>
            <param name="peer">peer to disconnect</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer,System.Byte[])">
            <summary>
            Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
            </summary>
            <param name="peer">peer to disconnect</param>
            <param name="data">additional data</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer,LiteNetLib.Utils.NetDataWriter)">
            <summary>
            Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
            </summary>
            <param name="peer">peer to disconnect</param>
            <param name="writer">additional data</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
            </summary>
            <param name="peer">peer to disconnect</param>
            <param name="data">additional data</param>
            <param name="start">data start</param>
            <param name="count">data length</param>
        </member>
        <member name="M:LiteNetLib.NetManager.CreateNtpRequest(System.Net.IPEndPoint)">
            <summary>
            Create the requests for NTP server
            </summary>
            <param name="endPoint">NTP Server address.</param>
        </member>
        <member name="M:LiteNetLib.NetManager.CreateNtpRequest(System.String,System.Int32)">
            <summary>
            Create the requests for NTP server
            </summary>
            <param name="ntpServerAddress">NTP Server address.</param>
            <param name="port">port</param>
        </member>
        <member name="M:LiteNetLib.NetManager.CreateNtpRequest(System.String)">
            <summary>
            Create the requests for NTP server (default port)
            </summary>
            <param name="ntpServerAddress">NTP Server address.</param>
        </member>
        <member name="F:LiteNetLib.NetManager.PacketPoolSize">
            <summary>
            Maximum packet pool size (increase if you have tons of packets sending)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.MaxPacketsReceivePerUpdate">
            <summary>
            Maximum packets count that will be processed in Manual PollEvents
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.Start(System.Net.IPAddress,System.Net.IPAddress,System.Int32,System.Boolean)">
            <summary>
            Start logic thread and listening on selected port
            </summary>
            <param name="addressIPv4">bind to specific ipv4 address</param>
            <param name="addressIPv6">bind to specific ipv6 address</param>
            <param name="port">port to listen</param>
            <param name="manualMode">mode of library</param>
        </member>
        <member name="T:LiteNetLib.ConnectionState">
            <summary>
            Peer connection state
            </summary>
        </member>
        <member name="T:LiteNetLib.NetPeer">
            <summary>
            Network peer. Main purpose is sending messages to specific peer.
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.EndPoint">
            <summary>
            Peer ip address and port
            </summary>
        </member>
        <member name="F:LiteNetLib.NetPeer.NetManager">
            <summary>
            Peer parent NetManager
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.ConnectionState">
            <summary>
            Current connection state
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.ConnectTime">
            <summary>
            Connection time for internal purposes
            </summary>
        </member>
        <member name="F:LiteNetLib.NetPeer.Id">
            <summary>
            Peer id can be used as key in your dictionary of peers
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.RemoteId">
            <summary>
            Id assigned from server
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.Ping">
            <summary>
            Current one-way ping (RTT/2) in milliseconds
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.RoundTripTime">
            <summary>
            Round trip time in milliseconds
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.Mtu">
            <summary>
            Current MTU - Maximum Transfer Unit ( maximum udp packet size without fragmentation )
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.RemoteTimeDelta">
            <summary>
            Delta with remote time in ticks (not accurate)
            positive - remote time > our time
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.RemoteUtcTime">
            <summary>
            Remote UTC time (not accurate)
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.TimeSinceLastPacket">
            <summary>
            Time since last packet received (including internal library packets)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetPeer.Tag">
            <summary>
            Application defined object containing data about the connection
            </summary>
        </member>
        <member name="F:LiteNetLib.NetPeer.Statistics">
            <summary>
            Statistics of peer connection
            </summary>
        </member>
        <member name="M:LiteNetLib.NetPeer.GetPacketsCountInReliableQueue(System.Byte,System.Boolean)">
            <summary>
            Returns packets count in queue for reliable channel
            </summary>
            <param name="channelNumber">number of channel 0-63</param>
            <param name="ordered">type of channel ReliableOrdered or ReliableUnordered</param>
            <returns>packets count in channel queue</returns>
        </member>
        <member name="M:LiteNetLib.NetPeer.CreatePacketFromPool(LiteNetLib.DeliveryMethod,System.Byte)">
            <summary>
            Create temporary packet (maximum size MTU - headerSize) to send later without additional copies
            </summary>
            <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <returns>PooledPacket that you can use to write data starting from UserDataOffset</returns>
        </member>
        <member name="M:LiteNetLib.NetPeer.SendPooledPacket(LiteNetLib.PooledPacket,System.Int32)">
            <summary>
            Sends pooled packet without data copy
            </summary>
            <param name="packet">packet to send</param>
            <param name="userDataSize">size of user data you want to send</param>
        </member>
        <member name="M:LiteNetLib.NetPeer.GetMaxSinglePacketSize(LiteNetLib.DeliveryMethod)">
            <summary>
            Gets maximum size of packet that will be not fragmented.
            </summary>
            <param name="options">Type of packet that you want send</param>
            <returns>size in bytes</returns>
        </member>
        <member name="M:LiteNetLib.NetPeer.SendWithDeliveryEvent(System.Byte[],System.Byte,LiteNetLib.DeliveryMethod,System.Object)">
            <summary>
            Send data to peer with delivery event called
            </summary>
            <param name="data">Data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
            <param name="userData">User data that will be received in DeliveryEvent</param>
            <exception cref="T:System.ArgumentException">
                If you trying to send unreliable packet type<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.SendWithDeliveryEvent(System.Byte[],System.Int32,System.Int32,System.Byte,LiteNetLib.DeliveryMethod,System.Object)">
            <summary>
            Send data to peer with delivery event called
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
            <param name="userData">User data that will be received in DeliveryEvent</param>
            <exception cref="T:System.ArgumentException">
                If you trying to send unreliable packet type<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.SendWithDeliveryEvent(LiteNetLib.Utils.NetDataWriter,System.Byte,LiteNetLib.DeliveryMethod,System.Object)">
            <summary>
            Send data to peer with delivery event called
            </summary>
            <param name="dataWriter">Data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
            <param name="userData">User data that will be received in DeliveryEvent</param>
            <exception cref="T:System.ArgumentException">
                If you trying to send unreliable packet type<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.ReadOnlyMemory{System.Byte},LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer (channel - 0)
            </summary>
            <param name="data">Data</param>
            <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(LiteNetLib.Utils.NetDataWriter,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer (channel - 0)
            </summary>
            <param name="dataWriter">DataWriter with data</param>
            <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.ReadOnlyMemory{System.Byte},System.Int32,System.Int32,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer (channel - 0)
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.ReadOnlyMemory{System.Byte},System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer
            </summary>
            <param name="data">Data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(LiteNetLib.Utils.NetDataWriter,System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer
            </summary>
            <param name="dataWriter">DataWriter with data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.ReadOnlyMemory{System.Byte},System.Int32,System.Int32,System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.SendWithDeliveryEvent(System.ReadOnlySpan{System.Byte},System.Byte,LiteNetLib.DeliveryMethod,System.Object)">
            <summary>
            Send data to peer with delivery event called
            </summary>
            <param name="data">Data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
            <param name="userData">User data that will be received in DeliveryEvent</param>
            <exception cref="T:System.ArgumentException">
                If you trying to send unreliable packet type<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.ReadOnlySpan{System.Byte},LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer (channel - 0)
            </summary>
            <param name="data">Data</param>
            <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.ReadOnlySpan{System.Byte},System.Byte,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer
            </summary>
            <param name="data">Data</param>
            <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
            <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="T:LiteNetLib.LocalAddrType">
            <summary>
            Address type that you want to receive from NetUtils.GetLocalIp method
            </summary>
        </member>
        <member name="T:LiteNetLib.NetUtils">
            <summary>
            Some specific network utilities
            </summary>
        </member>
        <member name="M:LiteNetLib.NetUtils.GetLocalIpList(LiteNetLib.LocalAddrType)">
            <summary>
            Get all local ip addresses
            </summary>
            <param name="addrType">type of address (IPv4, IPv6 or both)</param>
            <returns>List with all local ip addresses</returns>
        </member>
        <member name="M:LiteNetLib.NetUtils.GetLocalIpList(System.Collections.Generic.IList{System.String},LiteNetLib.LocalAddrType)">
            <summary>
            Get all local ip addresses (non alloc version)
            </summary>
            <param name="targetList">result list</param>
            <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        </member>
        <member name="M:LiteNetLib.NetUtils.GetLocalIp(LiteNetLib.LocalAddrType)">
            <summary>
            Get first detected local ip address
            </summary>
            <param name="addrType">type of address (IPv4, IPv6 or both)</param>
            <returns>IP address if available. Else - string.Empty</returns>
        </member>
        <member name="F:LiteNetLib.PooledPacket.MaxUserDataSize">
            <summary>
            Maximum data size that you can put into such packet
            </summary>
        </member>
        <member name="F:LiteNetLib.PooledPacket.UserDataOffset">
            <summary>
            Offset for user data when writing to Data array
            </summary>
        </member>
        <member name="P:LiteNetLib.PooledPacket.Data">
            <summary>
            Raw packet data. Do not modify header! Use UserDataOffset as start point for your data
            </summary>
        </member>
        <member name="M:LiteNetLib.Utils.CRC32C.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compute CRC32C for data
            </summary>
            <param name="input">input data</param>
            <param name="offset">offset</param>
            <param name="length">length</param>
            <returns>CRC32C checksum</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataReader.GetStringArray(System.Int32)">
            <summary>
            Note that "maxStringLength" only limits the number of characters in a string, not its size in bytes.
            Strings that exceed this parameter are returned as empty
            </summary>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataReader.GetString(System.Int32)">
            <summary>
            Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
            </summary>
            <returns>"string.Empty" if value > "maxLength"</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataReader.PeekString(System.Int32)">
            <summary>
            Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
            </summary>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataWriter.FromBytes(System.Byte[],System.Boolean)">
            <summary>
            Creates NetDataWriter from existing ByteArray
            </summary>
            <param name="bytes">Source byte array</param>
            <param name="copy">Copy array to new location or use existing</param>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataWriter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates NetDataWriter from existing ByteArray (always copied data)
            </summary>
            <param name="bytes">Source byte array</param>
            <param name="offset">Offset of array</param>
            <param name="length">Length of array</param>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataWriter.SetPosition(System.Int32)">
            <summary>
            Sets position of NetDataWriter to rewrite previous values
            </summary>
            <param name="position">new byte position</param>
            <returns>previous position of data writer</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataWriter.Put(System.String,System.Int32)">
            <summary>
            Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
            </summary>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RegisterNestedType``1">
            <summary>
            Register nested property type
            </summary>
            <typeparam name="T">INetSerializable structure</typeparam>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RegisterNestedType``1(System.Action{LiteNetLib.Utils.NetDataWriter,``0},System.Func{LiteNetLib.Utils.NetDataReader,``0})">
            <summary>
            Register nested property type
            </summary>
            <param name="writeDelegate"></param>
            <param name="readDelegate"></param>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RegisterNestedType``1(System.Func{``0})">
            <summary>
            Register nested property type
            </summary>
            <typeparam name="T">INetSerializable class</typeparam>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadAllPackets(LiteNetLib.Utils.NetDataReader)">
            <summary>
            Reads all available data from NetDataReader and calls OnReceive delegates
            </summary>
            <param name="reader">NetDataReader with packets data</param>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadAllPackets(LiteNetLib.Utils.NetDataReader,System.Object)">
            <summary>
            Reads all available data from NetDataReader and calls OnReceive delegates
            </summary>
            <param name="reader">NetDataReader with packets data</param>
            <param name="userData">Argument that passed to OnReceivedEvent</param>
            <exception cref="T:LiteNetLib.Utils.ParseException">Malformed packet</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadPacket(LiteNetLib.Utils.NetDataReader)">
            <summary>
            Reads one packet from NetDataReader and calls OnReceive delegate
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <exception cref="T:LiteNetLib.Utils.ParseException">Malformed packet</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadPacket(LiteNetLib.Utils.NetDataReader,System.Object)">
            <summary>
            Reads one packet from NetDataReader and calls OnReceive delegate
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <param name="userData">Argument that passed to OnReceivedEvent</param>
            <exception cref="T:LiteNetLib.Utils.ParseException">Malformed packet</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.Subscribe``1(System.Action{``0},System.Func{``0})">
            <summary>
            Register and subscribe to packet receive event
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <param name="packetConstructor">Method that constructs packet instead of slow Activator.CreateInstance</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.Subscribe``2(System.Action{``0,``1},System.Func{``0})">
            <summary>
            Register and subscribe to packet receive event (with userData)
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <param name="packetConstructor">Method that constructs packet instead of slow Activator.CreateInstance</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.SubscribeReusable``1(System.Action{``0})">
            <summary>
            Register and subscribe to packet receive event
            This method will overwrite last received packet class on receive (less garbage)
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.SubscribeReusable``2(System.Action{``0,``1})">
            <summary>
            Register and subscribe to packet receive event
            This method will overwrite last received packet class on receive (less garbage)
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RemoveSubscription``1">
            <summary>
            Remove any subscriptions by type
            </summary>
            <typeparam name="T">Packet type</typeparam>
            <returns>true if remove is success</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.RegisterNestedType``1">
            <summary>
            Register custom property type
            </summary>
            <typeparam name="T">INetSerializable structure</typeparam>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.RegisterNestedType``1(System.Func{``0})">
            <summary>
            Register custom property type
            </summary>
            <typeparam name="T">INetSerializable class</typeparam>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.RegisterNestedType``1(System.Action{LiteNetLib.Utils.NetDataWriter,``0},System.Func{LiteNetLib.Utils.NetDataReader,``0})">
            <summary>
            Register custom property type
            </summary>
            <typeparam name="T">Any packet</typeparam>
            <param name="writer">custom type writer</param>
            <param name="reader">custom type reader</param>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Register``1">
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Deserialize``1(LiteNetLib.Utils.NetDataReader)">
            <summary>
            Reads packet with known type
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <returns>Returns packet if packet in reader is matched type</returns>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Deserialize``1(LiteNetLib.Utils.NetDataReader,``0)">
            <summary>
            Reads packet with known type (non alloc variant)
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <param name="target">Deserialization target</param>
            <returns>Returns true if packet in reader is matched type</returns>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Serialize``1(LiteNetLib.Utils.NetDataWriter,``0)">
            <summary>
            Serialize object to NetDataWriter (fast)
            </summary>
            <param name="writer">Serialization target NetDataWriter</param>
            <param name="obj">Object to serialize</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Serialize``1(``0)">
            <summary>
            Serialize object to byte array
            </summary>
            <param name="obj">Object to serialize</param>
            <returns>byte array with serialized data</returns>
        </member>
        <member name="T:LiteNetLib.Utils.NtpPacket">
            <summary>
            Represents RFC4330 SNTP packet used for communication to and from a network time server.
            </summary>
            <remarks>
            <para>
            Most applications should just use the <see cref="P:LiteNetLib.Utils.NtpPacket.CorrectionOffset" /> property.
            </para>
            <para>
            The same data structure represents both request and reply packets.
            Request and reply differ in which properties are set and to what values.
            </para>
            <para>
            The only real property is <see cref="P:LiteNetLib.Utils.NtpPacket.Bytes" />.
            All other properties read from and write to the underlying byte array
            with the exception of <see cref="P:LiteNetLib.Utils.NtpPacket.DestinationTimestamp" />,
            which is not part of the packet on network and it is instead set locally after receiving the packet.
            </para>
            <para>
            Copied from <a href="https://guerrillantp.machinezoo.com/">GuerrillaNtp project</a>
            with permission from Robert Vazan (@robertvazan) under MIT license, see https://github.com/RevenantX/LiteNetLib/pull/236
            </para>
            </remarks>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.Bytes">
            <summary>
            Gets RFC4330-encoded SNTP packet.
            </summary>
            <value>
            Byte array containing RFC4330-encoded SNTP packet. It is at least 48 bytes long.
            </value>
            <remarks>
            This is the only real property. All other properties except
            <see cref="P:LiteNetLib.Utils.NtpPacket.DestinationTimestamp" /> read from or write to this byte array.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.LeapIndicator">
            <summary>
            Gets the leap second indicator.
            </summary>
            <value>
            Leap second warning, if any. Special value
            <see cref="F:LiteNetLib.Utils.NtpLeapIndicator.AlarmCondition" /> indicates unsynchronized server clock.
            Default is <see cref="F:LiteNetLib.Utils.NtpLeapIndicator.NoWarning" />.
            </value>
            <remarks>
            Only servers fill in this property. Clients can consult this property for possible leap second warning.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.VersionNumber">
            <summary>
            Gets or sets protocol version number.
            </summary>
            <value>
            SNTP protocol version. Default is 4, which is the latest version at the time of this writing.
            </value>
            <remarks>
            In request packets, clients should leave this property at default value 4.
            Servers usually reply with the same protocol version.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.Mode">
            <summary>
            Gets or sets SNTP packet mode, i.e. whether this is client or server packet.
            </summary>
            <value>
            SNTP packet mode. Default is <see cref="F:LiteNetLib.Utils.NtpMode.Client" /> in newly created packets.
            Server reply should have this property set to <see cref="F:LiteNetLib.Utils.NtpMode.Server" />.
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.Stratum">
            <summary>
            Gets server's distance from the reference clock.
            </summary>
            <value>
            <para>
            Distance from the reference clock. This property is set only in server reply packets.
            Servers connected directly to reference clock hardware set this property to 1.
            Statum number is incremented by 1 on every hop down the NTP server hierarchy.
            </para>
            <para>
            Special value 0 indicates that this packet is a Kiss-o'-Death message
            with kiss code stored in <see cref="P:LiteNetLib.Utils.NtpPacket.ReferenceId" />.
            </para>
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.Poll">
            <summary>
            Gets server's preferred polling interval.
            </summary>
            <value>
            Polling interval in log2 seconds, e.g. 4 stands for 16s and 17 means 131,072s.
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.Precision">
            <summary>
            Gets the precision of server clock.
            </summary>
            <value>
            Clock precision in log2 seconds, e.g. -20 for microsecond precision.
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.RootDelay">
            <summary>
            Gets the total round-trip delay from the server to the reference clock.
            </summary>
            <value>
            Round-trip delay to the reference clock. Normally a positive value smaller than one second.
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.RootDispersion">
            <summary>
            Gets the estimated error in time reported by the server.
            </summary>
            <value>
            Estimated error in time reported by the server. Normally a positive value smaller than one second.
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.ReferenceId">
            <summary>
            Gets the ID of the time source used by the server or Kiss-o'-Death code sent by the server.
            </summary>
            <value>
            <para>
            ID of server's time source or Kiss-o'-Death code.
            Purpose of this property depends on value of <see cref="P:LiteNetLib.Utils.NtpPacket.Stratum" /> property.
            </para>
            <para>
            Stratum 1 servers write here one of several special values that describe the kind of hardware clock they use.
            </para>
            <para>
            Stratum 2 and lower servers set this property to IPv4 address of their upstream server.
            If upstream server has IPv6 address, the address is hashed, because it doesn't fit in this property.
            </para>
            <para>
            When server sets <see cref="P:LiteNetLib.Utils.NtpPacket.Stratum" /> to special value 0,
            this property contains so called kiss code that instructs the client to stop querying the server.
            </para>
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.ReferenceTimestamp">
            <summary>
            Gets or sets the time when the server clock was last set or corrected.
            </summary>
            <value>
            Time when the server clock was last set or corrected or <c>null</c> when not specified.
            </value>
            <remarks>
            This Property is usually set only by servers. It usually lags server's current time by several minutes,
            so don't use this property for time synchronization.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.OriginTimestamp">
            <summary>
            Gets or sets the time when the client sent its request.
            </summary>
            <value>
            This property is <c>null</c> in request packets.
            In reply packets, it is the time when the client sent its request.
            Servers copy this value from <see cref="P:LiteNetLib.Utils.NtpPacket.TransmitTimestamp" />
            that they find in received request packet.
            </value>
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.ReceiveTimestamp">
            <summary>
            Gets or sets the time when the request was received by the server.
            </summary>
            <value>
            This property is <c>null</c> in request packets.
            In reply packets, it is the time when the server received client request.
            </value>
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.TransmitTimestamp">
            <summary>
            Gets or sets the time when the packet was sent.
            </summary>
            <value>
            Time when the packet was sent. It should never be <c>null</c>.
            Default value is <see cref="P:System.DateTime.UtcNow" />.
            </value>
            <remarks>
            This property must be set by both clients and servers.
            </remarks>
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.DestinationTimestamp">
            <summary>
            Gets or sets the time of reception of response SNTP packet on the client.
            </summary>
            <value>
            Time of reception of response SNTP packet on the client. It is <c>null</c> in request packets.
            </value>
            <remarks>
            This property is not part of the protocol and has to be set when reply packet is received.
            </remarks>
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.RoundTripTime">
            <summary>
            Gets the round-trip time to the server.
            </summary>
            <value>
            Time the request spent traveling to the server plus the time the reply spent traveling back.
            This is calculated from timestamps in the packet as <c>(t1 - t0) + (t3 - t2)</c>
            where t0 is <see cref="P:LiteNetLib.Utils.NtpPacket.OriginTimestamp" />,
            t1 is <see cref="P:LiteNetLib.Utils.NtpPacket.ReceiveTimestamp" />,
            t2 is <see cref="P:LiteNetLib.Utils.NtpPacket.TransmitTimestamp" />,
            and t3 is <see cref="P:LiteNetLib.Utils.NtpPacket.DestinationTimestamp" />.
            This property throws an exception in request packets.
            </value>
        </member>
        <member name="P:LiteNetLib.Utils.NtpPacket.CorrectionOffset">
            <summary>
            Gets the offset that should be added to local time to synchronize it with server time.
            </summary>
            <value>
            Time difference between server and client. It should be added to local time to get server time.
            It is calculated from timestamps in the packet as <c>0.5 * ((t1 - t0) - (t3 - t2))</c>
            where t0 is <see cref="P:LiteNetLib.Utils.NtpPacket.OriginTimestamp" />,
            t1 is <see cref="P:LiteNetLib.Utils.NtpPacket.ReceiveTimestamp" />,
            t2 is <see cref="P:LiteNetLib.Utils.NtpPacket.TransmitTimestamp" />,
            and t3 is <see cref="P:LiteNetLib.Utils.NtpPacket.DestinationTimestamp" />.
            This property throws an exception in request packets.
            </value>
        </member>
        <member name="M:LiteNetLib.Utils.NtpPacket.#ctor">
            <summary>
            Initializes default request packet.
            </summary>
            <remarks>
            Properties <see cref="P:LiteNetLib.Utils.NtpPacket.Mode" /> and <see cref="P:LiteNetLib.Utils.NtpPacket.VersionNumber" />
            are set appropriately for request packet. Property <see cref="P:LiteNetLib.Utils.NtpPacket.TransmitTimestamp" />
            is set to <see cref="P:System.DateTime.UtcNow" />.
            </remarks>
        </member>
        <member name="M:LiteNetLib.Utils.NtpPacket.#ctor(System.Byte[])">
            <summary>
            Initializes packet from received data.
            </summary>
        </member>
        <member name="M:LiteNetLib.Utils.NtpPacket.FromServerResponse(System.Byte[],System.DateTime)">
            <summary>
            Initializes packet from data received from a server.
            </summary>
            <param name="bytes">Data received from the server.</param>
            <param name="destinationTimestamp">Utc time of reception of response SNTP packet on the client.</param>
            <returns></returns>
        </member>
        <member name="T:LiteNetLib.Utils.NtpLeapIndicator">
            <summary>
            Represents leap second warning from the server that instructs the client to add or remove leap second.
            </summary>
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.LeapIndicator" />
        </member>
        <member name="F:LiteNetLib.Utils.NtpLeapIndicator.NoWarning">
            <summary>
            No leap second warning. No action required.
            </summary>
        </member>
        <member name="F:LiteNetLib.Utils.NtpLeapIndicator.LastMinuteHas61Seconds">
            <summary>
            Warns the client that the last minute of the current day has 61 seconds.
            </summary>
        </member>
        <member name="F:LiteNetLib.Utils.NtpLeapIndicator.LastMinuteHas59Seconds">
            <summary>
            Warns the client that the last minute of the current day has 59 seconds.
            </summary>
        </member>
        <member name="F:LiteNetLib.Utils.NtpLeapIndicator.AlarmCondition">
            <summary>
            Special value indicating that the server clock is unsynchronized and the returned time is unreliable.
            </summary>
        </member>
        <member name="T:LiteNetLib.Utils.NtpMode">
            <summary>
            Describes SNTP packet mode, i.e. client or server.
            </summary>
            <seealso cref="P:LiteNetLib.Utils.NtpPacket.Mode" />
        </member>
        <member name="F:LiteNetLib.Utils.NtpMode.Client">
            <summary>
            Identifies client-to-server SNTP packet.
            </summary>
        </member>
        <member name="F:LiteNetLib.Utils.NtpMode.Server">
            <summary>
            Identifies server-to-client SNTP packet.
            </summary>
        </member>
    </members>
</doc>
